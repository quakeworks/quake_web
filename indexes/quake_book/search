[{"title":"Overview","created_date":1639164014,"updated_date":1639164014,"order":"1","author":"","id":1,"content":"\n\n\n半个月前，我在准备一个材料，好不容易从我的博客、Todo、Notes 里找到了一些相关的素材。我使用了不同的工具来管理知识，Microsoft To Do 管理 idea、[Phodit](https://www.phodit.com/) + [Phodal.com](https://www.phodal.com/) 发布文章、Apple Notes 记录笔记等等，知识被分散在各个工具中。不利于我进行洞见，寻找灵感，与此同时，还缺乏书写和记录的方式。\n\n\n于是，我需要一个新的工具来融合到我的知识体系里，它应该是：\n\n\n* 开源的。可以自由扩展。\n* 分布式 + 本地化的。可以离线使用，方便于出差旅途中使用。\n* 版本化的。可以自由查看变更历史。\n* 开放的。可以自由与其它工具组合。如 Vim、VSCode 等。\n* 易于扩展。可以结合习惯用的工具。诸如于，基于 DSL 的编辑-发布分离的类 Web 模式，用于展示。如 MxGraph、Mermaid、Ledge Framework 等\n\n所以，就有了：<https://github.com/phodal/quake>\n\n# Quake：知识管理元框架\n\nQuake 的目标是构建面向**极客**的知识管理元框架，它可以：\n\n* 自由的文本内容管理。Todo 清单、文章管理、书评、笔记等。\n* 构建知识网络体系。定制化 markdown 链接\n* 抓住稍纵即逝的灵感。支持快速启动（CLI、TUI）与全局搜索\n* 自由的呈现画布。DSL 与自由画板\n\n简单来说，通过 Markdown 来记录数据，Git 来进行版本化，Terminal 来快速编辑，Web + Web Components 提供定制能力。\n\n## Quake 设计理念 1：数据代码化\n\nQuake 延续了 Ledge Framework 中非常成功地思想：文档代码化 + Markdown 图表化 + Git，来提供对于数据的管理。尽管我们没有在 Quake 中引入数据库，但是依旧可以提供如下所功能：\n\n1. 数据迁移。\n2. 历史状态。设计一个拥有历史状态的内容是一件麻烦的事情。\n3. 数据查询与更新。\n4. ……\n\n只是呢，现在的这些功能只能支持基本的开发。对于扩展来说，依旧是有问题的，未来需要提供简化版的 SQL，以提供更好的数据处理。而除了 SQL 之外，另外一种简单的方式，就是提供脚本语言的支持。\n\n## Quake 设计理念 2：自由定制\n\n设计一个能支持不同数据模型的知识管理系统痛苦了，需要大量地前期工作。因此，我们先构建了一个可以自定义数据格式的元数据引擎。让每个人都可以自定义的数据格式，并能为这些数据自定义视图，就能简化大量的工作。\n\n### 自定义数据类型\n\n在 Quake 里，通过 YAML 来定义数据格式，也可以从导出的数据后生成（通过 `quake cmd -i “quake.sync”` ）：\n\n```yaml\n  - type: notes\n    display: \"\"\n    fields:\n      - title: Title\n      - description: String\n      - category: String\n      - created_date: Date\n      - updated_date: Date\n      - author: String\n    actions: ~\n```\n\n生成对应的 markdown 文件，形如：`0001-time-support.md` 即 id + title 的形式，对文件再进行编辑：\n\n```javascript\n\ntitle: time support\nauthor:\ncontent:\ncreated_date: 2021-11-24 19:14:10\nupdated_date: 2021-11-24 19:14:10\n\n\nahaha\n```\n\n考虑到生态兼容的问题，所以在 Quake 里直接采用了 Jekyll 的 Front Matter 语法来定义数据。我们对于文件的编辑操作，即内容和相关的内容信息，都是直接基于这个 markdown 文件的。\n\n### 自定义显示组件\n\n进行中。\n\n现有的 Web 部分架构是基于 Web Component 构建的，以提供自定义的数据操作能力。如通过下述的代码，可以构建我们的编辑器，并进行对应的交互：\n\n```javascript\n  const editor = document.createElement('quake-editor');\n\n  editor.setAttribute('id', entry.id);\n  editor.setAttribute('title', entry.title);\n  editor.setAttribute('value', entry.content);\n  editor.addEventListener(\"onSave\", function (event) {\n    update_entry(params.type, params.id, {\n      title: event.detail.title,\n      content: event.detail.value.replaceAll(\"\\\\\\n\", \"\\n\")\n    })\n  });\n  return editor\n```\n\n对于不同的内容来说，也是类似的，只需要创建好对应的组件，处理相应的结果即可。通过这种方式，构建出常用的各种数据类型，并让所有的开发者都可以自定义。\n\n# 如何使用 Quake\n\n现阶段，Quake 面向的群体主要是极客、软件工程师，又或者是具备一定 IT 基础的软件开发人员。毕竟，我们还没有 GUI，还需要一系列的应用封装工作。不过，GUI 从架构上来说太重了，构建一个基于本地 Web + Terminal 的 MVP 版本反而更加容易，还能验证自由度的可行性。\n\n## 安装 Quake\n\nQuake 的安装在现阶段，还是比较麻烦的，还只能在 CLI 下进行（所以，我们面向开发者，我还有得选吗？）：\n\n1. 安装 Quake。\n   1. 有 Rust 环境的话，可以直接  `cargo install quake`\n   2. 没有 Rust 环境的话，可以从 [Quake Release](https://github.com/phodal/quake/releases) 页面下载。\n2. 安装搜索引擎（可选的）\n   1. macOS 用户，可以直接 `brew install meilisearch`\n   2. 其它操作系统的用户，建议访问官方进行：<https://github.com/meilisearch/MeiliSearch>\n3. 引入 Web 页面。可以从 [Quake Release](https://github.com/phodal/quake/releases) 页面下载 web.zip，并解压到某个目录。\n\n随后，到相应的文档目录，执行 \\`quake init\\`，就可以得到一个初始化的环境了。执行 `quake server` ，就可以进入 Web 页面使用了。\n\n## Quake Importer\n\n回到文章的开头，首先我们要解决的是数据迁移的问题。所以，上周末，我的主要工作是在数据迁移上，将不同的数据源转化为 Markdown。如在 [Quake Importer](https://github.com/phodal/quake/tree/master/quake_importer) 中，有下述相关数据源的文档：\n\n1. Django CMS 的相关文章\n2. Apple Notes（备忘录）的相关备忘\n3. Microsoft To do 的相关待办事项\n\n从我的数据来看，我大概有 888 篇的文章，99 个 Todo，还有 302 篇的备忘。当然了，我还有一部分抓取的资料存储在 Microsoft OneNote 上，这部分在后续需要进一步完善了。\n\n## Quake Cmd\n\n在导出相关数据，便可以通过  `quake cmd -i “quake.sync”` 命令同步生成定义不同内容类型的定义文件。\n\n随后，可以直接创建新的内容，只需要通过 `quake cmd -i “blog.add: Quake 一个知识管理元框架”` 来快速创建新的 `blog` 内容。Quake 优先通过 Terminal 实现了基本的 CRUD 功能，如此一来，我们不需要缓慢地启动笔记工具，才能完成一个快速的想法。我们可以利用大量地再成的基于 Terminal 编辑器，如 Vim，快速完成记录。\n\n在保存之后，我们将更新生成对应的 `csv` 数据索引文件，以面向 Terminal 提供快速的接口能力。\n\n## Quake Server\n\n当我们需要寻找灵感时，便可以通过 `quake server` 启动我们的 Web 服务，在上面搜索、索引知识、管理知识等。基于本地的 Markdown + Meili 搜索引擎，我们能构建最好的本地体验。Quake 的 Web UI 界面是基于一个个的 Web Component 构建的，这就意味着，在我们提供 CRUD API 的基础上，你可以结合我们提供的组件能力，自由地构建你的 Web UI。通过在 Quake 的配置文件 `.quake.yaml` 中修改 `server_location` 参数，就能使用自己开发的页面了。在这时，Quake 只是作为一个 Markdown 的 CRUD API。\n\n最后，因为所有的数据是围绕于 markdown + yaml 的，所以，我们可以结合 Git 进行版本化管理。（PS：这部分功能还没设计）\n\n## 下一步\n\n在完成了 MVP （最小可行产品）版本之后，依旧还有一系列的工作要做：\n\n* Terminal UI。已经有小伙伴工作在上面。\n* 定制 Markdown 语法。用于支持诸如于双链、文本图表化、脑图\n* 全局 GUI 入口。从全局搜索支持，类似于 Spotlight Search\n* Web 应用设计。现在的版本非常粗糙，缺乏各种功能。\n* 更好的知识管理。\n\n你可以在 Quake 的 [Story](https://github.com/phodal/quake/tree/master/_fixtures/story) 中看到更多的相关内容。\n\n如果你也有兴趣，欢迎加入我们。\n","type":"quake_book"},{"title":"Setup","created_date":1639164083,"updated_date":1639164083,"order":"","author":"","id":2,"content":"\n\n\n1. init, `quake init`\n2. config\n - `.quake.yml` to config quake\n -  edit `entries-define.yaml` to\n\n## Terminal GUI\n\n```\nquake tui\n```\n\n### CLI\n\n0. install\n\n```bash\ngit clone https://github.com/phodal/quake && cd quake\ncargo install --path .  # or: just install\n```\n\n1. add entry by type\n\n```bash\nquake cmd -i \"todo.add: time support\"\n```\n\n2. edit entry by index\n\n```bash\nquake cmd -i \"todo.edit(1)\"\n```\n\n3. list entry by type\n\n```bash\nquake cmd -i \"todo.list\"\n```\n\n4. sync list\n\n```bash\nquake cmd -i \"todo.sync\"\n```\n\n5. show entry\n\n```bash\nquake cmd -i \"todo.show(1)\"\n```\n\n### Web\n\n1. setup search engine\n\n```bash\nbrew install meilisearch\n```\n\nindex\n\n```\nquake cmd -i \"quake.feed\"\n```\n\n2. run server\n\n```\nquake server\n```\n\n3. visit: [http://localhost:9999/](http://localhost:9999/)\n\n### GUI (TBD)\n\nTBD\n","type":"quake_book"},{"title":"Transflow","created_date":1639164070,"updated_date":1639164070,"order":"","author":"","id":3,"content":"\n\nTransflow 的设计起源需要那篇《[类型流（TypeFlow）——世俗化的函数式编程和改进的过程式设计](https://zhuanlan.zhihu.com/p/341089716)》说起。Typeflow 有几个主要的规则：\n\n1. 从可视化模型上就可以看出：共存在4个待实现的函数，其中两个纯函数，参数校验和返回结果包装；一个副作用函数，保存代办事项；还有一个输入端口，即把这个几个函数编排起来完成业务的程序入口。\n2. 每个函数有明确的输入输出类型\n3. 函数之间通过匹配的输入输出类型连接起来。\n4. 输入输出类型使用业务人员能够理解的业务概念，从而符合DDD的要求。\n5. 可视化\n\n简单来说，在有了设计之后，我们可以为功能生成对应的有输入和输出的函数，并可以通过规则将它们匹配起来。原理，就是这么简单。\n\n## Transflow 初识：DSL 生成代码\n\n回到 Quake 的场景里，我们有固定的数据源，即不同的 entry。与此同时我们还有不同的用于展示这些数据的组件。\n\n然后，我们所需要做的便是，提供一个从数据流向组件的规则，即 Transflow DSL。\n\n### Transflow 示例\n\n举个例子，当我们想有一个 calendar 来展示所有的 todo 和 blog 时，我们就需要从数据源中取得 todo 和 blog，对数据进行转换然后传输给 calendar 组件。用一句话来表达便是：\n\n```javascript\nfrom('todo','blog').to(<quake-calendar>);\n```\n\n这个 Transflow 的 DSL，最简模式下（即没有函数名、不添加数据映射（mapping）和过滤器（filter）、组件定义的情况下），它可以生成以下的 JavaScript  代码：\n\n\n```javascript\nfunction from_todo_blog_to_quake_calendar(todos, blogs) {\n  let results = [];\n  results = results.concat(todos);\n  results = results.concat(blogs);\n  return results;\n}\n\nconst tl_temp_1 = async (context, commands) => {\n  const el = document.createElement('quake-calendar');\n\n  let todos = await Quake.query('todo');\n\n  let blogs = await Quake.query('blog');\n\n  let data = from_todo_blog_to_quake_calendar(todos, blogs);\n  el.setAttribute('data', JSON.stringify(data));\n\n  return el;\n}\n\n Quake.router.addRoutes({path: '/transflow/show_temp_1', action: tl_temp_1 },)\n```\n\n代码逻辑上是：\n\n1. 创建一个新的 Quake Calendar 组件（Web Component）\n2. 获取 todo、blog 相关的数据\n3. 执行对应的数据转换规则\n4. 将数据传递给组件\n5. 添加可访问的路由\n\n这样一来，只需要跳转到相应的路由即可。如果需要的话，也可以直接生成临时的组件。另外一部分，则是由 Web Components 所构建的组件体系，我们将会在另外一篇文章中展开介绍。\n\n### 多条 Transflow\n\n（PS：虽然尚未进行测试，但是我相信它当前是**不** work 的）\n\n如果有多条 Transflow 规则时：\n\n```javascript\ntransflow show_calendar {\n  from('todo','blog').to('record'),\n  from('record').to(<quake-calendar>);\n}\n```\n\n就会生成多个 Transflow 函数（部分）：\n\n```javascript\nfunction from_todo_blog_to_record(todos, blogs) {\n  let results = [];\n  results = results.concat(todos);\n  results = results.concat(blogs);\n  return results;\n}\n\nfunction from_record_to_quake_calendar(records) {\n  let results = [];\n  results = results.concat(records);\n  return results;\n}\n```\n\nTransflow 生成的代码，面临的最大问题是数据量大时的性能问题，但是 Quake 的场景下，不会有这样的问题。\n\n## 目标函数式的 Transflow\n\n既然，我们是对数据流进行操作，那么理想情况下，Transflow 的 DSL 就可以设计为向函数式靠齐。不过，当前，我们还没有理由实现这么复杂的功能，可以在后续展开。\n\n### 一个实现一点点的 map\n\n上述的 `from('todo','blog').to(<quake-calendar>);` 会在转化时生成特定的数据结构。因此，也可以直接从数据结构中读取对应的 Transflow，对它们进行存储：\n\n```yaml\n- name: \"from_todo_blog_to_quake_calendar_timeline\"\n  from: [ \"todo\", \"blog\" ]\n  to: \"<quake-calendar-timeline>\"\n  map:\n    - entry: \"todo\"\n      source: [\"title\", \"content\", \"start_time\", \"updated_date\"]\n      target: [\"title\", \"content\", \"created_date\", \"updated_date\"]\n    - entry: \"blog\"\n      source: [\"title\", \"content\", \"start_time\", \"updated_date\"]\n      target: [\"title\", \"content\", \"created_date\", \"updated_date\"]\n```\n\n\n这里的 `map` 是一个尚未在 DSL 设计的功能，也需要进一步验证是否真的需要。除此，这个 YAML 的设计也是有问题的。\n\n### 还有，一个刚可用的 filter\n\n在 filter 方面，我做了一些简化设计（\\~~~偷懒~~\\~），因为需要的是搜索引擎，可以可以直接使用搜索引擎的 fliter 功能。在评估了多个 filter-parser 的库之后，我发现没有理由在当前做这么复杂的设计。所以，针对于一些特别的过滤条件做了一些特别的处理。\n\n如下是一个过滤时间的表达式：\n\n```javascript\nfrom('todo','blog').to(<quake-calendar>).filter('created_date > 2021.01.01 AND created_date < 2021.12.31')\n```\n\n由于搜索引擎并不支持各种各样的时间处理，所以我们可以替换对应的字符器，然后：\n\n```javascript\ncreated_date > 1609459200 AND created_date < 1640908800\n```\n\n等时机成熟，再完成整体的 filter 规则设计。\n\n## 下一步：更简单的 Transflow\n\n还在设计中，预期可能会有组件中的编排等。不过，首先我们得需要有足够的 Web Components 组件，才能完成基本的功能开发，并收集这些数据场景。诸如于：\n\n- [ ] Todo 应用\n- [ ] Kanban 应用\n- [ ] Typeform 编辑器\n- [ ] 白板\n- [ ] ……\n\n### 双向绑定的中间组件：ComponentFlow\n\n理想的情况下，我们应该在 Transflow 中生成的是一个新的 Web Components 组件，以提供数据到组件的通道。只是呢，当前受限于当前的场景有限，所以提供的是简单的代码生成。等组件库进一步完善之后，便可以尝试引入这个新的设计。\n\n### 面向专业人士的 Transflow\n\n在 Quake 现有的设计里，专业人士可以自由自在的对 Quake 进行定制，所以并不需要高级的 Transflow 存在。\n","type":"quake_book"},{"title":"Development","created_date":1639164089,"updated_date":1639164089,"order":"","author":"","id":4,"content":"\n\n## Quake Markdown: QuakeDown 处理逻辑\n\n1. 通过 marked.js 解析 markdown，获得 `block` 级别的 token\n2. 遍历 token 构造不同类型（如 heading、code、list 等），生成新的 markdown 渲染数据。\n3. 遍历 markdownData，根据不同的条件渲染出 `block` 级别的 HTML，重写部分 `inline` 级别的 markdown。\n4. 分别为 `inline` 绑定事件。\n\n相关代码：\n\n- `extensions.ts` 相关扩展的声明代码。\n- `quake-down.ts` 重新生成 markdown 数据。\n- `quake-render.ts` 渲染页面。\n\n## 添加新的 markdown 语法\n\n1. 在 quake-render/src/utils/quake-down.ts 的 `quake-down.ts` 在 `extensions()` 方法中添加新的匹配规则。如：\n\n```javascript\nconst admonition = {\n  name: 'admonition',\n  level: 'block',  // marked.js 支持 `block` 和 `inline` 两种类型\n  start(src) {\n    return src.match(/!!!/)?.index;\n  },\n  tokenizer(src) {\n    const rule = /^!!! ([\\w\\-]+)(?: \"([^\\n]*?)\")?(?:\\s*\\n|\\s*$)((?:(?:\\t| {4})[^\\n]+(?:\\n|$)|\\s*(\\n|$))*)?/;\n    const match = rule.exec(src);\n    if (match) {\n      return {\n        type: 'admonition',\n        raw: match[0],\n        display_type: match[1]?.trim(),\n        title: match[2]?.trim(),\n        body: match[3]?.trim(),\n      };\n    }\n  },\n  renderer(token) {\n    return `<a>${token}</a>`;\n  },\n};\n```\n\n2. 在 `handleCustomBlock` 添加新类型的自定义数据。\n\n3. 根据定义的是 `block`（块）或者 `inline`（内联）属性，来决定渲染方式。\n   - `block` 需要在 `quake-render.tsx` 在 `conditionRender` 方法中添加渲染方式。\n   - `inline` 类型需要在：`quake-render.tsx` 在 `parseInline` 方法中添加渲染方式。\n\n\n\n","type":"quake_book"},{"title":"Custom Quake component","created_date":1639351889,"updated_date":1639351889,"order":"","author":"","id":5,"content":"\n\n\n## React\n\n\n## Angular\n\n\n## Vue\n\n\n## Stencil.js\n\n","type":"quake_book"},{"title":"Type System","created_date":1639383100,"updated_date":1639397440,"order":"","author":"","id":6,"content":"\n\nExamples:\n\n```yaml\n  - type: story\n    display: \"Story\"\n    fields:\n      - title: Title\n      - author: String\n      - content: Body\n      - status: Flow\n      - priority: State\n      - created_date: Date\n      - updated_date: Date\n    flows:\n      - field: status\n        items: ['Spike', 'Todo', 'Doing', 'Done']\n    states:\n      - field: priority\n        items: ['Low', 'Medium', 'High']\n```\n\n## field type: Date\n\n```yaml\n- explain: a date field will be convert to a standard Unix timestamp.\n- ability:\n    - can be filter by date\n- examples:\n    - created_date > 2021.01.01\n    - created_date > 2021.01.01 AND created_date < 2021.12.31\n```\n\n## field type: Flow\n\n```yaml\n- explain: a flow can show in Kanban mode and loging to system.\n- ability:\n    - kanban model\n    - loging\n```\n\na changing example:\n\n```yaml\nquake_change:\n  - 2021-12-09 09:32:28 \"Todo\"\n  - 2021-12-09 09:40:28 \"Spike\" -> \"Todo\"\n  - 2021-12-10 12:12:28 \"Todo\" -> \"Doing\"\n  - 2021-12-10 12:12:28 \"Doing\" -> \"Done\"\n```\n\n## field type: State\n\n","type":"quake_book"},{"title":"Quake's markdown syntax","created_date":1639487466,"updated_date":1639487466,"order":"","author":"","id":7,"content":"\n\n### Page link\n\n[[note:0001 \"markdown-syntax\"]]\n\nambiguous link\n\n[[\"title\"]]\n\n### Embed  link\n\n![[todo:0001 \"page-title\"]]\n\n### Admonition\n\n```\n!!! note \"An optional title\"\n    Here is something you should pay attention to.\n```\n\n### Auto Todo\n\n```\n>>> todo \"title\"\n    do something\n```\n\n### Code\n\n#### interactive code\n\n// like: https://juliadocs.github.io/Documenter.jl/stable/showcase/#Running-interactive-code\n\nInput:\n\n```@example(\"java\")\ncode_typed(sqrt, (Float64,))\n```\n\nOutput:\n\n```\n\n```\n\n#### repl code\n\nrun step by steps for repl languages\n\n```@repl(\"repl\") #1\nusing Statistics\nxs = collect(1:10)\nmedian(xs)\nsum(xs)\n```\n\n`#1` to tag code, can be auto insert\n\n```@repl_block(\"javascript\")\n\n```\n\n#### auto code connect\n\n```@connect\n\n```\n\n\n### Mathematics\n\n/// https://katex.org/\n/// use: https://www.mathjax.org/\n\n``A x^2 + B x + C = 0``\n\n### Link relations\n\n```\n<entry_type>:<entry_id> \"<entry_title>\" -> <entry_type>:<entry_id> \"<entry_title>\"\n```\n\n```\nnote:0001 \"title\" -> content:0001 \"2222\"\nnote:0002 -> title\n```\n","type":"quake_book"}]