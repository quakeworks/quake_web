[{"title":"Phodal.com Process","created_date":"2021-12-02 20:06:20","updated_date":"2021-12-02 20:06:20","id":1,"content":"\n\n```javascript\nlet text = \"\";\n$(\"h2.mdl-card__title-text > a\").each(function(index, link) {\n    text += `[${link.innerText}](${link.href}) \\n\\n`\n});\n\nconsole.log(text);\n```\n\n","type":"code"},{"title":"ledge usage","created_date":"2021-12-02 20:06:20","updated_date":"2021-12-02 20:06:20","id":2,"content":"\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"stylesheet\" href=\"https://theme.ledge.ink/styles.css\">\n    <base href=\"/\">\n</head>\n<body>\n<div id=\"ledge-content\"></div>\n</body>\n<script src=\"https://theme.ledge.ink/runtime-es5.js\"></script>\n<script src=\"https://theme.ledge.ink/polyfills-es5.js\"></script>\n<script src=\"https://theme.ledge.ink/main-es5.js\"></script>\n<script>\n    var content = document.getElementById('ledge-content');\n    var tile = document.createElement('ledge-theme');\n    var text = `\n\\`\\`\\`table-step\n| 项目 / 过程管理 | 配置管理 | 构建  | 测试 / 质量 | 制品 / 部署 | 基础设施 | 沟通协作 | 可视化   |\n|---|----|---|---|----|----|----|----|\n| Jira          | Gitee   | Maven | Junit      | Ubran code | VMWare  | 招呼     | Tableau |\n| Tracker       | Rational ClearCase |  Gradle | Cucumber | Fit2Cloud | OpenShift | 移事通 | Grafana |\n| VP            | CMDB | NPM | JMeter     | B9         | Cloud Foundry | | Kibana |\n| Confluence    |   Firefly    | Ant   | RobotFramework | JFrog Artifactory | | |  Prometheus |\n| ITIL          |    | MSBuild | Protractor | | | | ElasticSearch |\n|               |           |  Docker  | Sonar | | | | X-Pack |\n|               |           |        | BlackDuck | | | | |\n\nconfig: {\"rowHeight\": \"340px\" ,\"colors\": [{\"bg\":\"#e55852\",\"font\":\"#b71a09\"},{\"bg\":\"#e98832\",\"font\":\"#c85113\"},{\"bg\":\"#f0d668\",\"font\":\"#b88d0f\"},\n{\"bg\":\"#a4c9cf\",\"font\":\"#598893\"},{\"bg\":\"#47c0af\",\"font\":\"#175a54\"},\n{\"bg\":\"#387fd5\",\"font\":\"#9ac9f5\"},{\"bg\":\"#7753df\",\"font\":\"#cbb5f8\"},{\"bg\":\"#485cde\",\"font\":\"#a0b1f3\"}]}\n\\`\\`\\`\n`\n    tile.setAttribute('content', text);\n\n    content.appendChild(tile);\n</script>\n</html>\n```\n","type":"code"},{"title":"pulldown markdown processor","created_date":"2021-12-07 21:16:28","updated_date":"2021-12-07 21:16:28","id":3,"content":"\n\n```rust\n// Copyright 2015 Google Inc. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n//! HTML renderer that takes an iterator of events as input.\n\nuse std::collections::HashMap;\nuse std::io::{self, Write};\n\nuse pulldown_cmark::{Alignment, CodeBlockKind, CowStr, Event, LinkType, Tag};\nuse pulldown_cmark::escape::{StrWrite, WriteWrapper};\nuse pulldown_cmark::Event::*;\n\nuse crate::md_reader::code_reader::CodeReader;\nuse crate::parser::parser;\n\nenum TableState {\n    Head,\n    Body,\n}\n\nstruct TextWriter<'a, I, W> {\n    /// Iterator supplying events.\n    iter: I,\n\n    /// Writer to write to.\n    writer: W,\n\n    /// Whether or not the last write wrote a newline.\n    end_newline: bool,\n\n    table_state: TableState,\n    table_alignments: Vec<Alignment>,\n    table_cell_index: usize,\n    item_index: usize,\n    list_index: usize,\n    #[allow(dead_code)]\n    numbers: HashMap<CowStr<'a>, usize>,\n}\n\nimpl<'a, I, W> TextWriter<'a, I, W>\n    where\n        I: Iterator<Item=Event<'a>>,\n        W: StrWrite,\n{\n    fn new(iter: I, writer: W) -> Self {\n        Self {\n            iter,\n            writer,\n            end_newline: true,\n            table_state: TableState::Head,\n            table_alignments: vec![],\n            table_cell_index: 0,\n            item_index: 0,\n            list_index: 0,\n            numbers: HashMap::new(),\n        }\n    }\n\n    /// Writes a buffer, and tracks whether or not a newline was written.\n    #[inline]\n    fn write(&mut self, s: &str) -> io::Result<()> {\n        self.writer.write_str(s)?;\n\n        if !s.is_empty() {\n            self.end_newline = s.ends_with('\\n');\n        }\n        Ok(())\n    }\n\n    fn run(mut self) -> io::Result<()> {\n        while let Some(event) = self.iter.next() {\n            println!(\"{:?}\", event);\n            match event {\n                Start(tag) => {\n                    self.start_tag(tag)?;\n                }\n                End(tag) => {\n                    self.end_tag(tag)?;\n                }\n                Text(text) => {\n                    write!(&mut self.writer, \"{}\", &text)?;\n                    self.end_newline = text.ends_with('\\n');\n                }\n                Code(text) => {\n                    self.write(\"`\")?;\n                    write!(&mut self.writer, \"{}\", &text)?;\n                    self.write(\"`\")?;\n                }\n                Html(html) => {\n                    self.write(&html)?;\n                }\n                SoftBreak => {\n                    self.write(\"\\n\")?;\n                }\n                HardBreak => {\n                    self.write(\"\\n\")?;\n                }\n                Rule => {\n                    if self.end_newline {\n                        self.write(\"---\\n\")?;\n                    } else {\n                        self.write(\"\\n---\\n\")?;\n                    }\n                }\n                FootnoteReference(name) => {\n                    write!(&mut self.writer, \"[^{}]\", name)?;\n                }\n                TaskListMarker(true) => {\n                    self.write(\"[x] \")?;\n                }\n                TaskListMarker(false) => {\n                    self.write(\"[ ] \")?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes the start of an HTML tag.\n    fn start_tag(&mut self, tag: Tag<'a>) -> io::Result<()> {\n        match tag {\n            Tag::Paragraph => {\n                Ok(())\n            }\n            Tag::Heading(level) => {\n                write!(&mut self.writer, \"{} \", \"#\".repeat(level as usize).as_str())\n            }\n            Tag::Table(alignments) => {\n                self.table_alignments = alignments;\n                Ok(())\n            }\n            Tag::TableHead => {\n                self.table_state = TableState::Head;\n                self.table_cell_index = 0;\n                Ok(())\n            }\n            Tag::TableRow => {\n                self.table_cell_index = 0;\n                Ok(())\n            }\n            Tag::TableCell => {\n                self.write(\"|\")\n            }\n            Tag::BlockQuote => {\n                self.write(\"> \")\n            }\n            Tag::CodeBlock(info) => {\n                match info {\n                    CodeBlockKind::Fenced(info) => {\n                        let lang = info.split(' ').next().unwrap();\n                        if lang.is_empty() {\n                            return self.write(\"\\n```\");\n                        } else {\n                            write!(&mut self.writer, \"```{}\", lang)?;\n                            self.write(\"\\n\")?;\n                        }\n                    }\n                    CodeBlockKind::Indented => {\n                        return self.write(\"```\");\n                    }\n                }\n\n                let mut code_text = String::new();\n                if let Some(Event::Text(s)) = self.iter.next() {\n                    code_text.push_str(&s);\n                }\n\n                for line in code_text.lines() {\n                    if line.starts_with(\"// doc-\") {\n                        let writing = parser::parse(line.replace(\"//\", \"\").as_str());\n\n                        if writing.code_docs.len() > 0 {\n                            for code in CodeReader::read_doc_code(&writing.code_docs[0]) {\n                                write!(&mut self.writer, \"{}\\n\", code)?;\n                            }\n                        } else if writing.code_sections.len() > 0 {\n                            for code in CodeReader::read_doc_section(&writing.code_sections[0]) {\n                                write!(&mut self.writer, \"{}\\n\", code)?;\n                            }\n                        } else {\n                            write!(&mut self.writer, \"{}\\n\", line)?;\n                        }\n                    } else {\n                        write!(&mut self.writer, \"{}\\n\", line)?;\n                    }\n                }\n\n\n                Ok(())\n            }\n            Tag::List(Some(1)) => {\n                self.list_index = self.list_index + 1;\n                self.item_index = 1;\n                Ok(())\n            }\n            Tag::List(Some(start)) => {\n                self.list_index = self.list_index + 1;\n                self.item_index = start as usize;\n                Ok(())\n            }\n            Tag::List(None) => {\n                self.list_index = self.list_index + 1;\n                self.write(\"\")\n            }\n            Tag::Item => {\n                if self.item_index > 0 {\n                    write!(&mut self.writer, \"{}. \", self.item_index)?;\n                    self.item_index = self.item_index + 1;\n                    Ok(())\n                } else {\n                    self.write(\"\\n- \")\n                }\n            }\n            Tag::Emphasis => self.write(\"*\"),\n            Tag::Strong => self.write(\"**\"),\n            Tag::Strikethrough => self.write(\"~~\"),\n            Tag::Link(LinkType::Email, _dest, _title) => {\n                self.write(\"<\")\n            }\n            Tag::Link(_link_type, _dest, _title) => {\n                self.write(\"[\")\n            }\n            Tag::Image(_link_type, _dest, _title) => {\n                self.write(\"![\")\n            }\n            Tag::FootnoteDefinition(name) => {\n                write!(&mut self.writer, \"[^{}]: \", &*name)\n            }\n        }\n    }\n\n    fn end_tag(&mut self, tag: Tag) -> io::Result<()> {\n        match tag {\n            Tag::Paragraph => {\n                self.write(\"\\n\\n\")?;\n            }\n            Tag::Heading(_level) => {\n                self.write(\"\\n\\n\")?;\n            }\n            Tag::Table(_) => {\n                self.write(\"\\n\")?;\n            }\n            Tag::TableHead => {\n                self.write(\"|\\n\")?;\n                self.table_state = TableState::Body;\n\n                self.write(\"|\")?;\n                write!(&mut self.writer, \"{} \", \"------|\".repeat(self.table_alignments.len()).as_str())?;\n                self.write(\"\\n\")?;\n            }\n            Tag::TableRow => {\n                self.write(\"|\\n\")?;\n            }\n            Tag::TableCell => {\n                self.table_cell_index += 1;\n            }\n            Tag::BlockQuote => {\n                self.write(\"\")?;\n            }\n            Tag::CodeBlock(_) => {\n                self.write(\"```\\n\\n\")?;\n            }\n            Tag::List(Some(1)) => {\n                self.list_index = self.list_index - 1;\n                self.item_index = 0;\n                self.write(\"\\n\")?;\n            }\n            Tag::List(Some(_start)) => {\n                self.list_index = self.list_index - 1;\n                self.item_index = 0;\n                self.write(\"\\n\")?;\n            }\n            Tag::List(None) => {\n                self.list_index = self.list_index - 1;\n                self.write(\"\\n\")?;\n            }\n            Tag::Item => {\n                self.write(\"\\n\")?;\n            }\n            Tag::Emphasis => {\n                self.write(\"*\")?;\n            }\n            Tag::Strong => {\n                self.write(\"**\")?;\n            }\n            Tag::Strikethrough => {\n                self.write(\"~~\")?;\n            }\n            Tag::Link(link_type, dest, _title) => {\n                match link_type {\n                    LinkType::Email => {\n                        self.write(\">\")?;\n                    }\n                    _ => {\n                        self.write(\"](\")?;\n                        write!(&mut self.writer, \"{}\", dest)?;\n                        self.write(\")\")?;\n                    }\n                }\n            }\n            Tag::Image(_link_type, dest, _title) => {\n                self.write(\"](\")?;\n                write!(&mut self.writer, \"{}\", dest)?;\n                self.write(\")\")?;\n            }\n            Tag::FootnoteDefinition(_) => {}\n        }\n        Ok(())\n    }\n}\n\npub fn push_text<'a, I>(s: &mut String, iter: I)\n    where\n        I: Iterator<Item=Event<'a>>,\n{\n    TextWriter::new(iter, s).run().unwrap();\n}\n\npub fn write_text<'a, I, W>(writer: W, iter: I) -> io::Result<()>\n    where\n        I: Iterator<Item=Event<'a>>,\n        W: Write,\n{\n    TextWriter::new(iter, WriteWrapper(writer)).run()\n}\n\n\n#[cfg(test)]\nmod tests {\n    use std::io::Write;\n\n    use pulldown_cmark::{Options, Parser};\n\n    use crate::md_writer;\n\n    #[test]\n    fn should_parse_ol_list() {\n        let input = \"1. normal\n2. **strong**\n3. ~~delete~~\n4. *Italic*\n5. ***BoldAndItalic***\n\n\";\n        let parser = Parser::new(input);\n\n        let mut result: String = String::from(\"\");\n        md_writer::push_text(&mut result, parser);\n        assert_eq!(input, result);\n    }\n\n    #[test]\n    fn should_parse_normal_list() {\n        let input = \"- normal\n- **strong**\n- ~~delete~~\n- *Italic*\n- ***BoldAndItalic***\n\n\";\n        let parser = Parser::new(input);\n\n        let mut result: String = String::from(\"\");\n        md_writer::push_text(&mut result, parser);\n        assert_eq!(input, result);\n    }\n\n    #[test]\n    fn should_parse_footnote() {\n        let input = \"footnote[^1]\n\n[^1]: My reference.\n\n\";\n        let parser = Parser::new_ext(input, Options::all());\n\n        let mut result: String = String::from(\"\");\n        md_writer::push_text(&mut result, parser);\n        assert_eq!(input, result);\n    }\n\n    #[test]\n    fn should_build_email() {\n        let input = \"a <fake@example.com> a\n\n\";\n        let parser = Parser::new_ext(input, Options::all());\n\n        let mut result: String = String::from(\"\");\n        md_writer::push_text(&mut result, parser);\n        assert_eq!(input, result);\n    }\n\n    #[test]\n    fn should_build_table() {\n        let list = \"\n| Syntax      | Description |\n| ----------- | ----------- |\n| Header      | Title       |\n| Paragraph   | Text        |\n\";\n        let parser = Parser::new_ext(list, Options::all());\n\n        let stdout = std::io::stdout();\n        let mut handle = stdout.lock();\n        handle.write_all(b\"\\nHTML output:\\n\").unwrap();\n        md_writer::write_text(&mut handle, parser).unwrap();\n    }\n\n    #[test]\n    fn should_build_todo() {\n        let list = \"\n- [ ] workflow design\n   - [ ] collaboration style\n   - [ ] associate patterns\n- [ ] core driven style\n\";\n        let parser = Parser::new_ext(list, Options::all());\n\n        let mut result: String = String::from(\"\");\n        md_writer::push_text(&mut result, parser);\n        // assert_eq!(input, result);\n        println!(\"{}\", result);\n    }\n}\n```\n\n","type":"code"}]